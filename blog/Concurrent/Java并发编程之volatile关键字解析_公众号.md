###**引言**​
在设计模式之单例模式一文中，我们提到“双重检查加锁”机制的实现会使用关键字volatile，那么为什么要使用volatile？如果不使用volatile关键字会发生什么？带着这些疑问，我们一起来了解神秘的volatile。
###**认识volatile**​
在《Java并发编程实战》一书中，是这样描述volatile的：
        
    Java语音提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。
在《深入理解Java虚拟机》中写到：

    当一个变量定义为volatile之后，他将具备两种特性，第一是保证此变量对所有线程的可见性，这里的”可见性“是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成。例如，线程A修改一个普通变量的值，然后向主内存进行会写，另外一条线程B在线程A会写完成了之后再从主内存进行读取操作，新变量值才会对线程B可见。

    使用volatile变量的第二个语义是禁止指令重排序优化，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。
###**volatile关键字的二层语义**​

    1、保证被volatile修饰的变量对所有线程的可见性
    2、禁止指令重排序优化
###**深入解析volatile关键字**​
先看一段代码，假如线程1先执行，线程2后执行：
```java
//线程1
boolean stop = false;
while(!stop){
    doSomething();
}
//线程2
stop = true;
```
这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。
下面解释一下这段代码为何有可能导致无法中断线程。在Java中，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。
那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。
但是用volatile修饰之后就变得不一样了：
        
    第一：使用volatile关键字会强制将修改的值立即写入主存；
    第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效；
    第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。
在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。
最终线程1读取到的就是最新的正确的值。
再来看一段《深入理解Java虚拟机》中的示例代码：
```java
public class VolatileTest {
    public static volatile int race = 0;
    private static final int THREAD_COUNT = 20;
    public static void increase() {
        race++;
    }
    public static void main(String[] args) {
        Thread[] threads = new Thread[THREAD_COUNT];
        for (int i = 0; i < THREAD_COUNT; i++) {
            threads[i] = new Thread(() -> {
                for (int j = 0; j < 10000; j++) {
                    increase();
                }
            });
            threads[i].start();
        }
        while (Thread.activeCount() > 1) {
            Thread.yield();
        }
        System.out.println(race);
    }
}
```
这段代码发起了20个线程，每个线程对race变量进行10000次自增操作，如果这段代码能够正确并发的话，最后输出的结果应该是200000。但当我们运行完这段代码之后，并不会获得期望的结果，而且会发现每次运行程序，输出的结果都不一样，都是一个小于200000的数字。这是为什么呢？
问题就出在自增操作`race++`上面，事实上在JVM中，`race++`大概做了以下3件事情

    1、读取变量race的值
    2、把race进行加1操作
    3、把race的操作写入工作内存
由于我们不能保证上面这3件事情的连续性，假如执行顺序如下：

    1、线程1读取race的值后，还没有操作就被阻塞了;
    2、线程2被唤醒，从主存读取race的值，加1，然后被阻塞。（此时还没来得及把新的值重新赋值给race，当然也还没同步到主存）;
    3、线程1被唤醒，race值加1，然后同步到主存（线程1结束）;
    4、线程2被唤醒，把最新的值赋值给race，同步到主存（此时线程2，race的值在第2步时已经被处理过了， 仅仅只是把新的值赋值给race而已。这个时候是不会再去读取race的缓存行的，虽然race的缓存行此时已经无效了）。
那么，最终的输出结果就顺利成章的出错了。
在《深入理解Java虚拟机》一书中，作者从字节码层面分析了上面示例代码并发失败的原因：
```java
public static void increase();
  descriptor: ()V
  flags: ACC_PUBLIC, ACC_STATIC
  Code:
    stack=2, locals=0, args_size=0
       0: getstatic     #2                  // Field race:I
       3: iconst_1
       4: iadd
       5: putstatic     #2                  // Field race:I
       8: return
    LineNumberTable:
      line 20: 0
      line 21: 8
```
当getstatic指令把race的值取到操作栈顶时，volatile关键字保证了race的值在此时是正确的，但是在执行iconst_1、iadd这些指令的时候，其他线程可能已经把race的值加大了，而在操作栈顶的值就变成了过期的数据，所以putstatic指令执行后就可能把较小的race值同步回主内存中了。
以上解释了volatile的第一层语义：保证被volatile修饰的变量对所有线程的可见性。从上面知道volatile关键字保证了操作的可见性，但是volatile不能保证对变量的操作是原子性。
接着再来学习volatile的第二层语义：禁止指令重排序。
《深入理解Java虚拟机》中写到：

    从硬件架构上讲，指令重排序是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理。但并不是说指令任意重排，CPU需要能正确处理指令依赖情况以保障程序能得出正确的执行结果。譬如指令1把地址A中的值加10，指令2把地址A中的值乘以2，指令3把地址B中的值减去3，这时指令1和指令2是有依赖的，他们之间的顺序不能重排——(A+10)*2与A*2+10显然不相等，但指令3可以重排到指令1、2之前或者中间，只要保证CPU执行后面依赖到A、B值的操作时能获取到正确的A、B值即可。
###**回头看"双重检查加锁"**​
有人认为使用volatile的原因是其“可见性”特性，也就是可以保证线程在工作内存不会存有instance的副本，每次都是去主内存中读取。但其实是不对的。
对于`instance = new Singleton()`这句，这并非是一个原子操作，JVM中这句话大概做了下面3件事情
    
    1、给 instance 分配内存
    2、调用 Singleton 的构造函数来初始化成员变量
    3、将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）
假设我们不使用volatile修饰instance，由于在JVM的即时编译器中存在指令重排序的优化，也就是说上面的2和3的顺序是不能保证的，最终的执行顺序可能是1-2-3也可能是1-3-2；
如果是后者，则线程一在3执行完毕，2未执行之前，被线程二抢占了，这时 instance已经是非null了（但却没有初始化）；所以线程二会直接返回instance，然后使用，然后顺理成章地报错。
其实使用volatile的主要原因是其另一个特性：禁止指令重排序优化。
《深入理解Java虚拟机》中写到：

     观察加入volatile和未加入volatile关键字时所生成汇编代码的区别
     通过对比就会发现，关键变化在于有volatile修饰的变量，赋值后多执行了一个“lock addl $0x0,(%esp)"操作，这个操作相当于一个内存屏障。
也就是说，在volatile变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完1-2-3之后或者1-3-2之后，不存在执行到1-3然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个volatile变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。

    维基百科：内存屏障
    1、内存屏障，也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。
    2、大多数现代计算机为了提高性能而采取乱序执行，这使得内存屏障成为必须。
    3、语义上，内存屏障之前的所有写操作都要写入内存；内存屏障之后的读操作都可以获得同步屏障之前的写操作的结果。因此，对于敏感的程序块，写操作之后、读操作之前可以插入内存屏障。
###**结束语**​
至此我们算是基本明白了文章开头所提到的疑问，需要注意的是在Java5以前的版本使用volatile的“双重检查加锁”还是有问题的。其原因是Java5以前的Java内存模型是存在缺陷的，即使将变量声明成volatile也不能完全避免重排序，主要是volatile变量前后的代码仍然存在重排序问题。这个volatile屏蔽重排序的问题在Java5中才得以修复。

本文涉及到Java的内存模型，博主将新开一文。
本文参考资料：
《深入理解Java虚拟机》
《Java并发编程实战》
《Effective Java中文版》
https://www.cnblogs.com/dolphin0520/p/3920373.html