## 隔离级别
- **1、读未提交（Read UnCommitted）**
  ```
  事务A修改了数据后，无论该事务A有没有提交，其他任何事务都可以读取到事务A修改后的数据
  
  潜在问题：当事务A修改数据后提交之前，其他事务读取到A修改后的数据，并在该数据基础上进行操作。
  此时事务A提交失败数据回滚，数据则出现错误。称其他事务读取到A事务修改但未提交的数据为“脏读”。
  
  锁机制：读数据时不加共享锁，允许其他事务更改数据，则可能读到其他事务未提交的数据。  
- **2、读已提交（Read Commited）**
  ```
  事务A修改了数据，只有A提交之后，其他事务才可以看到A修改后的数据。解决了“脏读”。
    
  潜在问题：事务B读取了数据后，事务A对该数据进行了修改并提交，此时事务B再次以相同条件读取数据，
  发现前后两次读取的数据不一致，这就是所谓的“不可重复读”。
    
  锁机制：读取数据时正常加共享锁即可，读完释放，无论事务有没有提交。
  因为共享锁和排他锁互斥，所以只可能读到排他锁被释放（即提交/回滚后）后的数据。  
- **3、可重复读（Repeatable Read）**
  ```
  当使用可重复读隔离级别时，在事务执行期间会锁定该事务以任何方式引用的所有行。
  因此，如果在同一个事务中发出同一个SELECT语句两次或更多次，那么产生的结果数据集总是相同的。
  因此，使用可重复读隔离级别的事务可以多次检索同一行集，并对它们执行任意操作，直到提交或回滚操作终止该事务。
  解决了“脏读”、“不可重复读”。
  
  锁机制：对事务A扫描范围内的数据加U锁或S锁，并一直持有直到事务结束。
  因此其他事务不可以修改数据，但是可以读取数据。但是可以通过插入新数据的方式改变事务A的结果集。  
- **4、串行化（Serializable）**
  ```
  串行读，很容易理解，就是各个事务之间完全隔离，串行执行。

  存在问题：已经不是潜在问题了，问题很明显，串行执行，那么并发效率就很低。
  
  锁机制：加Range lock，范围锁可以覆盖到所查询出的行的索引的键值范围，而任何其他事务对范围内数据的修改、
  添加和删除都需要修改索引，所以此时将会被阻塞，因为范围锁覆盖了索引条目。  
---
## 脏读、不可重复读、幻读
- **1、脏读**
  ```
  事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据
- **2、不可重复读**
  ```
  不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，
  导致事务A多次读取同一数据时，结果 不一致
- **3、幻读**
  ```
  系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，
  但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，
  就好像发生了幻觉一样，这就叫幻读
- **总结**
  ```
  不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除

|事务隔离级别 |  脏读 | 不可重复读 | 幻读 | 
|:----- | :----: | :----: | :----:|
|读未提交（Read UnCommitted）|  是 | 是 | 是|        
|读已提交（Read Commited）|  否 | 是 | 是|        
|可重复读（Repeatable Read）|  否 | 否 | 是 |       
|串行化（Serializable） | 否 | 否 | 否  |
--- 
## 数据库默认隔离级别
- 1、Mysql
  ```
  默认的事务隔离级别是可重复读(Repeatable Read)
- 2、Oracle、SqlServer
  ```
  Oracle，SqlServer中都是选择读已提交(Read Commited)作为默认的隔离级别
--- 
## Mysql Binlog

- 1、Binlog简介？
  ```
  MySQL 的二进制日志 binlog 可以说是 MySQL 最重要的日志，
  它记录了所有的 DDL 和 DML 语句（除了数据查询语句select、show等），
  以事件形式记录，还包含语句所执行的消耗的时间，MySQL的二进制日志是事务安全型的。
  binlog 的主要目的是复制和恢复。
  
- 2、写 Binlog 的时机
  ```
  对支持事务的引擎如InnoDB而言，必须要提交了事务才会记录binlog。
  binlog 什么时候刷新到磁盘跟参数 sync_binlog 相关。
  
  - 如果设置为0，则表示MySQL不控制binlog的刷新，由文件系统去控制它缓存的刷新；
  
  - 如果设置为不为0的值，则表示每 sync_binlog 次事务，MySQL调用文件系统的刷新操作刷新binlog到磁盘中。
  
  - 设为1是最安全的，在系统故障时最多丢失一个事务的更新，但是会对性能有所影响。
  
  如果 sync_binlog=0 或 sync_binlog大于1，当发生电源故障或操作系统崩溃时，
  可能有一部分已提交但其binlog未被同步到磁盘的事务会被丢失，恢复程序将无法恢复这部分事务。
  
  在MySQL 5.7.7之前，默认值 sync_binlog 是0，MySQL 5.7.7和更高版本使用默认值1，这是最安全的选择。
  一般情况下会设置为100或者0，牺牲一定的一致性来获取更好的性能。

- 3、Binlog有几种格式？
  ```
  STATEMENT：基于SQL语句的复制（statement-based replication, SBR），每条修改数据的SQL都会保存到Binlog里面。
    - 优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO, 提高了性能。
    - 缺点：由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的一些相关信息，
            以保证所有语句能在slave得到和在master端执行的时候相同的结果。
            另外mysql的复制，像一些特定函数的功能，slave与master要保持一致会有很多相关问题。
  
  ROW：基于行的复制（row-based replication, RBR）（从5.1.5版本开始?）
    - 优点：binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。
            所以row的日志内容会非常清楚的记录下每一行数据修改的细节。
            而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题。
    - 缺点：所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容。
  
    注：将二进制日志格式设置为ROW时，有些更改仍然使用基于语句的格式，包括所有DDL语句，
        例如CREATE TABLE， ALTER TABLE，或 DROP TABLE。
    
  MIXED：混合模式复制（mixed-based replication, MBR）（从5.1.8版本开始?）。
    - 在Mixed模式下，一般的语句修改使用statment格式保存binlog，
      如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog，
      MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种。
  
  在 MySQL 5.7.7 之前，默认的格式是 STATEMENT，在 MySQL 5.7.7 及更高版本中，默认值是 ROW。
  日志格式通过 binlog-format 指定，如 binlog-format=STATEMENT、binlog-format=ROW、binlog-format=MIXED。
- 4、Binlog日志的两个最重要的使用场景
  ```
  主从复制：MySQL Replication在Master端开启binlog，Master把它的二进制日志传给slaves来达到master-slave数据一致。
  
  数据恢复：通过使用 mysqlbinlog工具来使恢复数据。
--- 
## Mysql默认可重复读的原因
- 1、Mysql主从复制，是基于什么复制的？
  ```
  是基于Binlog复制的。
  
- 2、主从数据不一致
  ```
  Mysql在5.0这个版本以前，binlog只支持STATEMENT这种格式!
  而这种格式在读已提交(Read Commited)这个隔离级别下主从复制是有bug的，
  因此Mysql将可重复读(Repeatable Read)作为默认的隔离级别!
--- 
## 提问
- 1、为什么在互联网项目将隔离级别设为RC(Read Commited)？
  ```
  缘由一：在RR隔离级别下，存在间隙锁，导致出现死锁的几率比RC大的多!
  
  缘由二：在RR隔离级别下，条件列未命中索引会锁表! 而在RC隔离级别下，只锁行。
  
  缘由三：在RC隔离级别下，半一致性读(semi-consistent)特性增加了update操作的并发性!
  
- 2、在RC级别下，不可重复读问题需要解决么？
  ```
  不用解决，这个问题是可以接受的!毕竟你数据都已经提交了，读出来本身就没有太大问题!
  Oracle的默认隔离级别就是RC，你们改过Oracle的默认隔离级别么？
- 3、在RC级别下，主从复制用什么binlog格式？
  ```
  在该隔离级别下，用的binlog为row格式，是基于行的复制! Innodb的创始人也是建议binlog使用该格式!