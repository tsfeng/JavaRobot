数据库规范
===
+ 作者：曹树芋


一 基础规范
---
1. 禁止一个MySQL实例存放多个业务数据库。
   + 解读：
      1. 会造成业务耦合性过高，一旦出现问题会殃及池鱼，增加了定位故障问题的难度。通常采用多实例解决，一个实例一个业务库，互不干扰。
1. 禁止在主库上执行后台管理和统计类的功能查询。
   + 解读：
      1. 这种复杂类的SQL会造成CPU的升高，进而会影响业务。
1. 人为涉及业务上的修改/删除数据，在得到业务方、CTO的邮件批准后方可执行，执行前提前做好备份，必要时可逆。
1. 所有上线需求必须走工单系统，口头通知视为无效。
1. 在对大表做表结构变更时，必须在业务低峰期执行。
   + 解读：
      1. 如修改字段属性会造成锁表，并会造成从库延迟，从而影响线上业务。
1. 表存储引擎必须使用InnoDB。
   + 解读：
      1. 支持事务，行级锁，更好的恢复性，高并发下性能更好。
1. 表字符集默认使用utf8，必要时候使用utf8mb4
   + 解读：
      1. 通用，无乱码风险，汉字3字节，英文1字节。utf8mb4是utf8的超集，有存储4字节例如表情符号时，使用它。
1. 禁止使用存储过程，视图，触发器，Event
   + 解读：
      1. MySQL是OLTP应用，最擅长简单的增、删、改、查操作，但对逻辑计算分析类的应用，并不适合，所以这部分的需求最好通过程序上实现。
      1. 对数据库性能影响较大，互联网业务，能让站点层和服务层干的事情，不要交到数据库层
      1. 调试，排错，迁移都比较困难，扩展性较差
1. 禁止在数据库中存储大文件。例如照片，可以将大文件存储在对象存储系统，数据库中存储路径。
1. 禁止在线上环境做数据库压力测试。
1. 禁止在数据库中存储明文密码。
1. 尽量减少数据库上的计算操作
   + 解读：
      1. 将那些需要耗费cpu资源计算数据的操作尽可能的放在服务器上运行，不要所有的数学计算全部抛给数据库，减小数据库开销，提升效率。
1. 合理的分库分表，按照具体的业务需求，合理的设计数据库和表，将数据合理分开存储。
1. 对事务一致性要求不高的业务，如日志表等，优先选择存入MongoDB。
   + 解读：
      1. 其自身支持的sharding分片功能，增强了横向扩展的能力，开发不用过多调整业务代码。
1. 所有表和字段都需要添加中文注释。

二 命名规范
---
1. 库名，表名，列名必须用小写，采用下划线分隔。
   + 解读：
      1. abc，Abc，ABC都是给自己埋坑
1. 库名，表名，列名必须见名知义，长度不要超过32字符。
1. 库备份必须以bak为前缀，以日期为后缀。
1. 从库必须以-s为后缀。
1. 备库必须以-ss为后缀。

三 表设计规范
---
1. 单实例表个数必须控制在2000个以内。
1. 单表分表个数必须控制在1024个以内。
1. 表必须有主键，推荐使用自增的UNSIGNED整数为主键。
   + 解读：
      1. 这样可以保证数据行是按照顺序写入，对于SAS传统机械式硬盘写入性能更好，根据主键做关联查询的性能也会更好，并且还方便了数据仓库抽取数据。
      1. 无主键的表，如果是row模式的主从架构，从库会挂住
      1. 从性能的角度来说，使用UUID作为主键是个最不好的方法，它会使插入变得随机。
1. 避免使用外键，如果要保证完整性，应由应用程式实现。
   + 解读：
      1. 外键使得表之间相互耦合，影响update/delete等SQL性能，有可能造成死锁，高并发情况下容易成为数据库瓶颈
      1. 外键用来保护参照完整性，可在业务端实现。
1. 禁止使用分区表。
   + 解读：
      1. 查询的字段必须是分区键，否则会遍历所有的分区表，并不会带来性能上的提升。
1. 建议将大字段，访问频度低的字段拆分到单独的表中存储，分离冷热数据。

四、列设计规范
---

1. 字段长度尽量按实际需要进行分配，不要随意分配一个很大的容量。
1. 根据业务区分使用tinyint/int/bigint，分别会占用1/4/8字节。
1. 根据业务区分使用char/varchar。
   + 解读：
      1. 字段长度固定，或者长度近似的业务场景，适合使用char，能够减少碎片，查询性能高
      1. 字段长度相差较大，或者更新较少的业务场景，适合使用varchar，能够减少空间
1. 根据业务区分使用datetime/timestamp。
   + 解读：
      1. 前者占用5个字节，后者占用4个字节，存储年使用YEAR，存储日期使用DATE，存储时间使用datetime
1. 必须把字段定义为NOT NULL并设默认值
   + 解读：
      1. NULL的列使用索引，索引统计，值都更加复杂，MySQL更难优化
      1. NULL需要更多的存储空间
      1. NULL只能采用IS NULL或者IS NOT NULL，而在=/!=/in/not in时有大坑
      1. 你应该用0、一个特殊的值或者一个空串代替空值。
      1. 含有空值的列很难进行查询优化，而且对表索引时不会存储NULL值的，所以如果索引的字段可以为NULL，索引的效率会下降很多。
1. 使用INT UNSIGNED存储IPv4，不要用char(15)。
1. 使用varchar(20)存储手机号，不要使用整数。
   + 解读：
      1. 牵扯到国家代号，可能出现+/-/()等字符，例如+86
      1. 手机号不会用来做数学运算
      1. varchar可以模糊查询，例如like ‘138%’
1. 使用TINYINT来代替ENUM
   + 解读：
      1. 存在扩展的问题，ENUM增加新值要进行DDL操作
1. 用DECIMAL代替FLOAT和DOUBLE存储精确浮点数。
   + 解读：
      1. 浮点数的缺点是会引起精度问题
1. 尽量不使用TEXT、BLOB类型。
   + 解读：
      1. TEXT,BLOB增加存储空间的占用，读取速度慢。可以使用varchar保存数据，尽量使用varchar，比text和blog性能好很多。
1. 最好使用数值类型存储
   + 解读：
      1. 占用空间小，计算快

五、索引规范
---
1. 索引不是越多越好，按实际需要进行创建
1. 唯一索引使用uniq_[字段名]来命名
1. 非唯一索引使用idx_[字段名]来命名
1. 单张表索引数量建议控制在5个以内
   + 解读：
      1. 互联网高并发业务，太多索引会影响写性能
      1. 生成执行计划时，如果索引太多，会降低性能，并可能导致MySQL选择不到最优索引
      1. 异常复杂的查询需求，可以选择ES等更为适合的方式存储
1. 组合索引字段数不建议超过5个
   + 解读：
      1. 如果5个字段还不能极大缩小row范围，八成是设计有问题
1. 不建议在频繁更新的字段上建立索引
1. 非必要不进行JOIN查询，如果要进行JOIN查询，被JOIN的字段存储字节尽可能小并且必须类型相同，并建立索引
1. 理解组合索引最左前缀原则，避免冗余或重复索引，如果建立了(a,b,c)，相当于建立了(a), (a,b), (a,b,c)
1. 理解最左匹配原则。
   + 解读：
      1. 数据库会一直向右匹配直到遇到范围查询就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的；
      1. =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序；
1. 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可；
1. 不在低基数列上建立索引。
   + 例如：‘sex' 'state'
1. 查询的字段必须创建索引。
   + 例如：SELECT、UPDATE、DELETE语句的WHERE条件列；多表JOIN的字段。

六、SQL规范
---
1. 禁止使用select *，只获取必要字段
   + 解读：
      1. select *会增加cpu/io/内存/带宽的消耗
      1. 指定字段能有效利用索引覆盖
      1. 指定字段查询，在表结构变更时，能保证对应用程序无影响
1. 避免使用COUNT(*)操作。
   + 解读：
      1. 因内部没有计数器，需要一行一行累加计算，计数统计实时要求较强可以使用memcache或者Redis。
1. 禁止SQL语句没有where条件
1. insert必须指定字段，禁止使用insert into T values()
   + 解读：
      1. 指定字段插入，在表结构变更时，能保证对应用程序无影响
1. WHERE条件规范
   1. 应尽量避免在where条件中对字段进行 null 值判断
   1. 应尽量避免在where条件中使用!=或<>操作符
   1. 应尽量避免在where条件中使用 or 来连接条件（可以使用union来代替or）
   1. 禁止where条件中出现数据类型不一致
   1. 禁止where条件中对索引列进行数学运算、使用函数或者表达式
   1. 禁止负向查询（not in / not like）以及%开头的模糊查询
   1. where条件中，对于连续的数值，能用between就不要用in
   + 解读：
      1. 导致不能命中索引，全表扫描
1. 禁止大表JOIN和子查询
1. 同一个字段上的OR必须改写问IN，IN的值必须少于50个
1. 应用程序必须捕获SQL异常
   + 解读：
      1. 方便定位线上问题
1. 减少与数据库的交互次数。
    ```sql
        INSERT INTO t (id, name) VALUES(1,'Bea');
        INSERT INTO t (id, name) VALUES(2,'Belle');
        INSERT INTO t (id, name) VALUES(3,'Bernice');
    ```
    修改为：
    ```sql
       INSERT INTO t (id, name) VALUES(1,'Bea'), (2,'Belle'),(3,'Bernice')
    ```
1. 禁止使用order by rand()
    ```sql
       SELECT * FROM t1 WHERE 1=1 ORDER BY RAND() LIMIT 4;
    ```
    修改为：
     ```sql
       SELECT * FROM t1 WHERE id >= CEIL(RAND()*1000) LIMIT 4;
     ```

1. 尽量杜绝3种大的sql操作，拆分成小SQL
   + 第一种：超长的sql语句，而且往往是多表查询，建议拆分多条，减少查询的字段等
   + 第二种：事物比较长的sql语句，容易失败，并且会影响其他sql的执行
   + 第三种：批量的sql数据执行
   
1. 非业务必须在同一事务内的的操作必须拆离主业务事务操作

1. 对单字段过长或无法预测最大长度的字段，可以采用分段存储的方式进行存储。
   ```
       基本字段设计如下：
       id(int) 自增主键
       ident_id(int) 标识ID，用于标示数据组所属，一般为关联数据的主键
       sign(int)所属序列位置，一般为数据数组的下标，从0开始
       value_info(varchar)存储的分割后的数据，在使用时可以根据sign进行拼接还原
       status(tinyint)数据状态，用于不用的数据进行标记，假删除使用
       具体设计可根据业务进行修改
   ```

