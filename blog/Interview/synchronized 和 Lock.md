Synchronized和Lock的区别
并发编程中，锁是经常需要使用的。在开发中我们常用的锁有两种Synchronized和Lock。

线程安全问题
线程安全是在多线程编程中，有可能会出现同时访问同一个 共享、可变资源 的情况，始终都不会导致数据破坏以及其他不该出现的结果。这种资源可以是一个变量、一个对象、一个文件等。

共享：多个线程可以同时访问该共享变量。
可变：数据在生命周期中可以被改变。

锁的概念
JAVA 内置锁
隐性锁：每个JAVA对象可以用作实现同步的内置锁，线程在访问同步代码块时必须先获取该内置锁，在退出和中断的时候需要释放内置锁。Java内置锁通过synchronized关键字使用，使用其修饰方法或者代码块，就能保证方法或者代码块以同步方式执行。有对象锁和类锁（static方法和class上枷锁）区分，两者不冲突可以并行存在。

显性锁：显式锁(ReentrantLock)正式为了解决这些灵活需求而生，ReentrantLock的字面意思是可重入锁，可重入的意思是线程可以同时多次请求同一把锁，而不会自己导致自己死锁。

锁的分类
可重入锁：Synchronized和ReentrantLook都是可重入锁，锁的可重入性标明了锁是针对线程分配方式而不是针对方法。例如调用Synchronized方法A中可以调用Synchronized方法B，而不需要重新申请锁。

读写锁：按照数据库事务隔离特性的类比读写锁，在访问统一个资源（一个文件）的时候，使用读锁来保证多线程可以同步读取资源。ReadWriteLock是一个读写锁，通过readLock()获取读锁，通过writeLock()获取写锁。

可中断锁：可中断是指锁是可以被中断的，Synchronized内置锁是不可中断锁，ReentrantLock可以通过lockInterruptibly方法中断显性锁。例如线程B在等待等待线程A释放锁，但是线程B由于等待时间太久，可以主动中断等待锁。

公平锁：公平锁是指尽量以线程的等待时间先后顺序获取锁，等待时间最久的线程优先获取锁。synchronized隐性锁是非公平锁，它无法保证等待的线程获取锁的顺序，ReentrantLook可以自己控制是否公平锁。

两种锁的底层实现
Synchronized：底层使用指令码方式来控制锁的，映射成字节码指令就是增加来两个指令：monitorenter和monitorexit。当线程执行遇到monitorenter指令时会尝试获取内置锁，如果获取锁则锁计数器+1，如果没有获取锁则阻塞；当遇到monitorexit指令时锁计数器-1，如果计数器为0则释放锁。

Lock：底层是CAS乐观锁，依赖AbstractQueuedSynchronizer类，把所有的请求线程构成一个CLH队列。而对该队列的操作均通过Lock-Free（CAS）操作。

Synchronized和Lock比较
Synchronized是关键字，内置语言实现，Lock是接口。
Synchronized在线程发生异常时会自动释放锁，因此不会发生异常死锁。Lock异常时不会自动释放锁，所以需要在finally中实现释放锁。
Lock是可以中断锁，Synchronized是非中断锁，必须等待线程执行完成释放锁。
Lock可以使用读锁提高多线程读效率。