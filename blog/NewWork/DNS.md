##### DNS    
    DNS（Domain Name System，域名系统），
    因特网上作为域名和IP地址相互映射的一个分布式数据库，
    能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。
    通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。
    
##### 几个问题：
- 1、浏览器是怎么知道DNS解析服务器，如上图的8.8.8.8这台？

      手动设置：
        
      动态分配： 通过动态主机配置协议(DHCP)，当一台设备连到路由器之后，路由器通过DHCP给它分配一个IP地址，并告诉它DNS服务器
        
- 2、一个域名可以解析成多个IP地址吗，如果只有一个IP地址，在并发量很大的情况下，那台服务器可能会爆？
- 3、把域名绑了host之后，是不是就不用域名解析了直接用的本地host指定的IP地址？
- 4、域名解析的有效时间为多长，即过了多久后同一个域名需要再次进行解析？
- 5、什么是域名解析的A记录、AAAA记录、CNAME记录？

      A就是把域名解析到一个IPv4地址，
      而AAAA是解析到IPv6地址，
      CNAME是解析到另外一个域名。
    
##### 在浏览器地址栏输入URL，按下回车后究竟发生了什么
- 第一步：浏览器输入域名
     
      例如：www.baidu.com
      
- 第二步：【DNS域名解析】-浏览器查找域名的IP地址

      DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 
      浏览器缓存，
      系统缓存，
      路由器缓存，
      IPS服务器缓存，
      根域名服务器缓存，比如 .com
      顶级域名服务器缓存，比如 google.com
      主域名服务器缓存。 比如 www.google.com
      
      递归查询
      
      迭代查询
      
- 第三步：建立TCP连接      
    
      三次握手：
      1）建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；
      2）服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（seq=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
      3）客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态
      客户机与服务器之间的TCP连接建立完成，开始通信。
      
      SYN：同步序列编号（Synchronize Sequence Numbers）

- 第四步：发送HTTP请求  
- 第五步：服务器处理请求  

       如果服务器给浏览器进行一个301永久重定向响应，浏览器根据重定向地址再次进行HTTP请求。 

- 第六步：返回响应结果  

      返回状态码200 OK，表示服务器可以响应请求，返回报文
      由于在报头中Content-type为“text/html”，浏览器以HTML形式呈现，而不是下载文件。
        
- 第七步：关闭TCP连接  
        
      四次挥手：
      1）客户端进程发出连接释放报文，并且停止发送数据。
         释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），
         此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
      2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，
         此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。
         TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，
         这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。
         这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。

         客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，
         等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
         
      3）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，
         由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，
         此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
         
      4）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，
         此时，客户端就进入了TIME-WAIT（时间等待）状态。
         注意此时TCP连接还没有释放，必须经过2∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
         
         服务器只要收到了客户端发出的确认，立即进入CLOSED状态。
         同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

         MSL（Maximum Segment Lifetime）：它是任何报文在网络上存在的最长的最长时间,超过这个时间报文将被丢弃。
         
         
      
      为什么要4次挥手？
      
      确保数据能够完整传输。
      当被动方收到主动方的FIN报文通知时，它仅仅表示主动方没有数据再发送给被动方了。
      但未必被动方所有的数据都完整的发送给了主动方，所以被动方不会马上关闭SOCKET,它可能还需要发送一些数据给主动方后，
      再发送FIN报文给主动方，告诉主动方同意关闭连接，所以这里的ACK报文和FIN报文多数情况下都是分开发送的。
      
      为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？
      
      虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。
      所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。
      在Client发送出最后的ACK回复，但该ACK可能丢失。
      Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。
      Client会在发送出ACK之后进入到TIME_WAIT状态。
      Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。
      所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。
      如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

      
- 第七步：浏览器解析HTML，布局渲染  
  