一、使用场景：
        假设现在要设计一个贩卖各类书籍的电子商务网站的购物车系统。一个最简单的情况就是把所有货品的单价乘上数量，但是实际情况肯定比这要复杂。
比如，本网站可能对所有的高级会员提供每本20%的促销折扣；对中级会员提供每本10%的促销折扣；对初级会员没有折扣。
　　根据描述，折扣是根据以下的几个算法中的一个进行的：
　　算法一：对初级会员没有折扣。
　　算法二：对中级会员提供10%的促销折扣。
　　算法三：对高级会员提供20%的促销折扣。

二、认识策略模式
　　1）策略模式的重心
　　      策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。
　　2）算法的平等性
　　     策略模式一个很大的特点就是各个策略算法的平等性。对于一系列具体的策略算法，大家的地位是完全一样的，
        正因为这个平等性，才能实现算法之间可以相互替换。
        所有的策略算法在实现上也是相互独立的，相互之间是没有依赖的。所以可以这样描述这一系列策略算法：策略算法是相同行为的不同实现。
　　3）运行时策略的唯一性
　　      运行期间，策略模式在每一个时刻只能使用一个具体的策略实现对象，虽然可以动态地在不同的策略实现中切换，但是同时只能使用一个。
　　4）公有的行为
　　      经常见到的是，所有的具体策略类都有一些公有的行为。这时候，就应当把这些公有的行为放到共同的抽象策略角色Strategy类里面。
        当然这时候抽象策略角色必须要用Java抽象类实现，而不能使用接口。
　　这其实也是典型的将代码向继承等级结构的上方集中的标准做法。

三、策略模式的优点
　　1）策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。
　　2）使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，
        统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。

四、策略模式的缺点
　　1）客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。
        换言之，策略模式只适用于客户端知道算法或行为的情况。
　　2）由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。


====================================================================================
Strategy模式有下面的一些优点：
1) 相关算法系列 Strategy类层次为Context定义了一系列的可供重用的算法或行为。 继承有助于析取出这些算法中的公共功能。
2) 提供了可以替换继承关系的办法： 继承提供了另一种支持多种算法或行为的方法。
你可以直接生成一个Context类的子类，从而给它以不同的行为。但这会将行为硬行编制到 Context中，
而将算法的实现与Context的实现混合起来,从而使Context难以理解、难以维护和难以扩展，而且还不能动态地改变算法。
最后你得到一堆相关的类 , 它们之间的唯一差别是它们所使用的算法或行为。
将算法封装在独立的Strategy类中使得你可以独立于其Context改变它，使它易于切换、易于理解、易于扩展。
3) 消除了一些if else条件语句 ：Strategy模式提供了用条件语句选择所需的行为以外的另一种选择。
当不同的行为堆砌在一个类中时 ,很难避免使用条件语句来选择合适的行为。将行为封装在一个个独立的Strategy类中消除了这些条件语句。
含有许多条件语句的代码通常意味着需要使用Strategy模式。
4) 实现的选择 Strategy模式可以提供相同行为的不同实现。客户可以根据不同时间 /空间权衡取舍要求从不同策略中进行选择。

Strategy模式缺点:

1)客户端必须知道所有的策略类，并自行决定使用哪一个策略类:本模式有一个潜在的缺点，
就是一个客户要选择一个合适的Strategy就必须知道这些Strategy到底有何不同。
此时可能不得不向客户暴露具体的实现问题。因此仅当这些不同行为变体与客户相关的行为时 , 才需要使用Strategy模式。
2) Strategy和Context之间的通信开销 ：无论各个ConcreteStrategy实现的算法是简单还是复杂,
它们都共享Strategy定义的接口。因此很可能某些 ConcreteStrategy不会都用到所有通过这个接口传递给它们的信息；
简单的 ConcreteStrategy可能不使用其中的任何信息！这就意味着有时Context会创建和初始化一些永远不会用到的参数。
如果存在这样问题 , 那么将需要在Strategy和Context之间更进行紧密的耦合。
3)策略模式将造成产生很多策略类：可以通过使用享元模式在一定程度上减少对象的数量。
增加了对象的数目 Strategy增加了一个应用中的对象的数目。
有时你可以将 Strategy实现为可供各Context共享的无状态的对象来减少这一开销。
任何其余的状态都由 Context维护。Context在每一次对Strategy对象的请求中都将这个状态传递过去。
共享的 Strategy不应在各次调用之间维护状态。
====================================================================================
github
当存在以下情况时使用Strategy模式
1）• 许多相关的类仅仅是行为有异。 “策略”提供了一种用多个行为中的一个行为来配置一个类的方法。即一个系统需要动态地在几种算法中选择一种。
2）• 需要使用一个算法的不同变体。例如，你可能会定义一些反映不同的空间 /时间权衡的算法。当这些变体实现为一个算法的类层次时 ,可以使用策略模式。
3）• 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。
4）• 一个类定义了多种行为 , 并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句。

====================================================================================
1）策略模式是一个比较容易理解和使用的设计模式，策略模式是对算法的封装，它把算法的责任和算法本身分割开，
委派给不同的对象管理。策略模式通常把一个系列的算法封装到一系列的策略类里面，作为一个抽象策略类的子类。
用一句话来说，就是“准备一组算法，并将每一个算法封装起来，使得它们可以互换”。
2）在策略模式中，应当由客户端自己决定在什么情况下使用什么具体策略角色。2）
3）策略模式仅仅封装算法，提供新算法插入到已有系统中，以及老算法从系统中“退休”的方便，
策略模式并不决定在何时使用何种算法，算法的选择由客户端来决定。这在一定程度上提高了系统的灵活性，
但是客户端需要理解所有具体策略类之间的区别，以便选择合适的算法，这也是策略模式的缺点之一，在一定程度上增加了客户端的使用难度。
