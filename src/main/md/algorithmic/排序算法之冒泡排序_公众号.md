###**基本实现**​
​冒泡排序的基本思想：比较两个相邻的元素，如果第一个比第二个大，则交换他们两个。
那么问题来了：假设有一数组如下，要求从小到大排序
```java
int[] a = {35, 26, 26, 9, 28, 42};
```
毫无疑问，最终的有序数组应该如下
```java
int[] a = {9, 26, 26, 28, 35, 42};
```
根据冒泡排序的基本思想，我们首先想到的逻辑是下面的：
```java
public static void bubbleSort(int[] a) {
    for (int i = 0; i < a.length - 1; i++) {
        for (int j = 0; j < a.length - 1 - i; j++) {
            if (a[j] > a[j + 1]) {
                int temp = a[j];
                a[j] = a[j + 1];
                a[j + 1] = temp;
            }
        }
    }
}
```
###**优化实现**​
那么现在假设数组如下，仍要求从小到大排序
```java
int[] a = {26, 9, 26, 28, 35, 42};
```
通过观察可以看到，从第一次循环交换前两个元素后，之后的所有操作都是没必要的，因为后面的元素已经是有序的。那么，有没有办法来避免这些没必要的操作呢？答案当然是：有。
我们假设有一个标志位flag，将其初始值设置为数组的长度，表示排序的边界值，每一次排序开始前将flag值置为0，在进行数据交换时，修改flag为最后发生数据交换的位置。在新一轮排序开始时，检查此标志，若此标志为0，表示上一次没有做过交换数据，无需排序则结束排序；否则进行排序
```java
public static void bubbleSort(int[] a) {
    int flag = a.length;
    while (flag > 0) {
        int k = flag;
        flag = 0;
        for (int j = 1; j < k; j++) {
            if (a[j - 1] > a[j]) {
                int temp = a[j];
                a[j] = a[j - 1];
                a[j - 1] = temp;
                flag = j;
            }
        }
    }
}
```
###**性能分析**
最佳情况下的时间复杂度：如果元素本来就是有序的，那么循环一次数组既可以完成排序工作，比较和移动元素的次数分别是n-1和0，因此最佳情况的时间复杂度为O(n)。
最差情况的时间复杂度：如果数据元素本来就是逆序的，则需要循环n-1次数组排序，所需比较和移动次数分别为n（n-1）/2和3n(n-1)/2。因此最坏情况子下的时间复杂度为O(n²)。
稳定性：因为每次比较后如果两个相邻元素相等我们并不会将他们交换，所以冒泡不会改变相同元素的下标，所以冒泡排序是一个稳定的排序。
